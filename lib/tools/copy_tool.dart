import 'dart:math' as math;
import 'package:flutter/material.dart';
import '../models/drawing_document.dart';
import '../models/entities.dart';
import '../services/document_service.dart';
import '../utils/geometry_utils.dart';
import 'base_tool.dart';

/// Copy tool implementation
class CopyTool extends BaseTool {
  String? selectedEntityId;
  Offset? copyStart;
  Entity? entityToCopy;
  
  @override
  void onPointerDown(Offset point, DrawingDocument document, DocumentService documentService, BuildContext context) {
    // When copy tool is active and we click, try to select an entity and start copying it
    if (entityToCopy == null) {
      // First click: select the entity to copy
      String? hitEntityId;
      double minDistance = double.infinity;

      for (final entity in document.visibleEntities) {
        if (entity.hitTest(point, Matrix4.identity(), 5.0)) {
          // For overlapping entities, select the one closest to the click point
          double distance = 0.0;

          if (entity is LineEntity) {
            distance = GeometryUtils.distanceToLineSegment(point, entity.start, entity.end);
          } else if (entity is CircleEntity) {
            distance = (GeometryUtils.distanceToCircle(point, entity.center, entity.radius)).abs();
          } else if (entity is EllipseEntity) {
            distance = GeometryUtils.distanceToEllipse(point, entity.center, entity.radiusX, entity.radiusY).abs();
          } else if (entity is RectangleEntity) {
            // For rectangles, use minimum distance to any edge
            final edges = [
              [entity.topLeft, Offset(entity.bottomRight.dx, entity.topLeft.dy)],
              [Offset(entity.bottomRight.dx, entity.topLeft.dy), entity.bottomRight],
              [entity.bottomRight, Offset(entity.topLeft.dx, entity.bottomRight.dy)],
              [Offset(entity.topLeft.dx, entity.bottomRight.dy), entity.topLeft],
            ];
            
            double minEdgeDist = double.infinity;
            for (final edge in edges) {
              final edgeDist = GeometryUtils.distanceToLineSegment(point, edge[0], edge[1]);
              minEdgeDist = math.min(minEdgeDist, edgeDist);
            }
            distance = minEdgeDist;
          } else {
            // For other entities like polylines, arcs, etc.
            distance = 1.0;
          }

          if (distance < minDistance) {
            minDistance = distance;
            hitEntityId = entity.id;
          }
        }
      }

      if (hitEntityId != null) {
        documentService.selectEntity(hitEntityId);
        selectedEntityId = hitEntityId;
        copyStart = point;
        
        // Store the entity to copy
        entityToCopy = document.visibleEntities
            .where((e) => e.id == hitEntityId)
            .firstOrNull;
      }
    } else {
      // Second click: place the copy at the new location
      final delta = point - copyStart!;
      createCopy(delta, documentService);
      
      // Reset state to allow for multiple copies
      copyStart = point;
    }
  }
  
  @override
  void onPointerMove(Offset point, DrawingDocument document, DocumentService documentService, BuildContext context) {
    if (entityToCopy == null || copyStart == null) return;
    
    // Calculate the move delta for preview
    final delta = point - copyStart!;
    
    // Update the preview entity
    previewEntity = createCopyEntity(entityToCopy!, delta);
  }
  
  @override
  void onPointerUp(Offset point, DrawingDocument document, DocumentService documentService, BuildContext context) {
    // We don't clear the state here to allow for multiple copies
    // The state will be cleared when the tool is deactivated or when the user switches tools
  }
  
  @override
  void clearState() {
    super.clearState();
    selectedEntityId = null;
    copyStart = null;
    entityToCopy = null;
    previewEntity = null;
  }
  
  void createCopy(Offset delta, DocumentService documentService) {
    if (entityToCopy == null) return;
    
    final copiedEntity = createCopyEntity(entityToCopy!, delta);
    documentService.addEntity(copiedEntity);
  }
  
  Entity createCopyEntity(Entity entity, Offset delta) {
    // Create a new entity with the same properties but moved by delta
    // We need to create a completely new entity with a new ID
    if (entity is LineEntity) {
      return LineEntity(
        start: entity.start + delta,
        end: entity.end + delta,
        layer: entity.layer,
        color: entity.color,
        lineWidth: entity.lineWidth,
        isSelected: entity.isSelected,
        // id is auto-generated by the Entity constructor
      );
    } else if (entity is CircleEntity) {
      return CircleEntity(
        center: entity.center + delta,
        radius: entity.radius,
        layer: entity.layer,
        color: entity.color,
        lineWidth: entity.lineWidth,
        isSelected: entity.isSelected,
      );
    } else if (entity is RectangleEntity) {
      return RectangleEntity(
        topLeft: entity.topLeft + delta,
        bottomRight: entity.bottomRight + delta,
        layer: entity.layer,
        color: entity.color,
        lineWidth: entity.lineWidth,
        isSelected: entity.isSelected,
      );
    } else if (entity is ArcEntity) {
      return ArcEntity(
        center: entity.center + delta,
        radius: entity.radius,
        startAngle: entity.startAngle,
        endAngle: entity.endAngle,
        layer: entity.layer,
        color: entity.color,
        lineWidth: entity.lineWidth,
        isSelected: entity.isSelected,
      );
    } else if (entity is EllipseEntity) {
      return EllipseEntity(
        center: entity.center + delta,
        radiusX: entity.radiusX,
        radiusY: entity.radiusY,
        layer: entity.layer,
        color: entity.color,
        lineWidth: entity.lineWidth,
        isSelected: entity.isSelected,
      );
    } else if (entity is PolylineEntity) {
      // Copy all points of the polyline with the delta
      List<Offset> newPoints = entity.points.map((p) => p + delta).toList();
      return PolylineEntity(
        points: newPoints,
        layer: entity.layer,
        color: entity.color,
        lineWidth: entity.lineWidth,
        isSelected: entity.isSelected,
      );
    } else if (entity is SplineEntity) {
      // Copy all control points of the spline with the delta
      List<Offset> newControlPoints = entity.controlPoints.map((p) => p + delta).toList();
      return SplineEntity(
        controlPoints: newControlPoints,
        layer: entity.layer,
        color: entity.color,
        lineWidth: entity.lineWidth,
        isSelected: entity.isSelected,
        showControlPoints: entity.showControlPoints,
        splineType: entity.splineType,
        tension: entity.tension,
      );
    } else {
      // Unknown entity type
      print('Warning: Attempted to copy unsupported entity type: ${entity.runtimeType}');
      return entity;
    }
  }
  
  @override
  MouseCursor getCursor() {
    return SystemMouseCursors.copy;
  }
  
  @override
  Entity? getPreviewEntity(DrawingDocument document) {
    return previewEntity;
  }
}
